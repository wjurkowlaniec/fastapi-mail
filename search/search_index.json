{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Fastapi-mail \u00b6 The fastapi-mail simple lightweight mail system, sending emails and attachments(individual && bulk) Using Jinja2 HTML Templates \u00b6 In order to use Jinja template langauge, your must specify email folder within your applications working directory. In sending HTML emails, the CSS expected by mail servers -outlook, google, etc- must be inline CSS. Fastapi mail passes \"body\" to the rendered template. In creating the template for emails the dynamic objects should be used with the assumption that the variable is named \" body \" and that it is a python dict. check out jinja2 for more details jinja2 Guide for Email Utils \u00b6 The utility allows you to check temporary email addresses, you can block any email or domain. You can connect Redis to save and check email addresses. If you do not provide a Redis configuration, then the utility will save it in the list or set by default. Writing unittests using Fastapi-Mail \u00b6 Fastapi mails allows you to write unittest for your application without sending emails to non existent email address by mocking the email to be sent. To mock sending out mails, set the suppress configuraton to true. Suppress send defaults to False to prevent mocking within applications. Support for Reply-To header is added \u00b6 Use this just like bcc but to specify addresses that should receive a reply to your message. E-mail systems MAY respect this as per RFC 2822.","title":"FastApi MAIL"},{"location":"#fastapi-mail","text":"The fastapi-mail simple lightweight mail system, sending emails and attachments(individual && bulk)","title":"Fastapi-mail"},{"location":"#using-jinja2-html-templates","text":"In order to use Jinja template langauge, your must specify email folder within your applications working directory. In sending HTML emails, the CSS expected by mail servers -outlook, google, etc- must be inline CSS. Fastapi mail passes \"body\" to the rendered template. In creating the template for emails the dynamic objects should be used with the assumption that the variable is named \" body \" and that it is a python dict. check out jinja2 for more details jinja2","title":"Using Jinja2 HTML Templates"},{"location":"#guide-for-email-utils","text":"The utility allows you to check temporary email addresses, you can block any email or domain. You can connect Redis to save and check email addresses. If you do not provide a Redis configuration, then the utility will save it in the list or set by default.","title":"Guide for Email Utils"},{"location":"#writing-unittests-using-fastapi-mail","text":"Fastapi mails allows you to write unittest for your application without sending emails to non existent email address by mocking the email to be sent. To mock sending out mails, set the suppress configuraton to true. Suppress send defaults to False to prevent mocking within applications.","title":"Writing unittests using Fastapi-Mail"},{"location":"#support-for-reply-to-header-is-added","text":"Use this just like bcc but to specify addresses that should receive a reply to your message. E-mail systems MAY respect this as per RFC 2822.","title":"Support for Reply-To header is added"},{"location":"contribute/","text":"Contributing to fastapi-mail \u00b6 We welcome contributions to fastapi-mail Issues \u00b6 Feel free to submit issues and enhancement requests. Fatapi-Mail Issues Contributing \u00b6 Please refer to each project's style and contribution guidelines for submitting patches and additions. In general, we follow the \"fork-and-pull\" Git workflow. Fork the repo on GitHub Clone the project to your own machine Commit changes to your own branch Push your work Submit a Pull request so that we can review your changes Before Start \u00b6 $ bash fastapi-mail.sh install $ source .venv/bin/activate $ cat app.py uvicorn app:app --port 8000 --reload NOTE: Be sure to merge the latest from upstream before making a pull request!","title":"Contribution"},{"location":"contribute/#contributing-to-fastapi-mail","text":"We welcome contributions to fastapi-mail","title":"Contributing to fastapi-mail"},{"location":"contribute/#issues","text":"Feel free to submit issues and enhancement requests. Fatapi-Mail Issues","title":"Issues"},{"location":"contribute/#contributing","text":"Please refer to each project's style and contribution guidelines for submitting patches and additions. In general, we follow the \"fork-and-pull\" Git workflow. Fork the repo on GitHub Clone the project to your own machine Commit changes to your own branch Push your work Submit a Pull request so that we can review your changes","title":"Contributing"},{"location":"contribute/#before-start","text":"$ bash fastapi-mail.sh install $ source .venv/bin/activate $ cat app.py uvicorn app:app --port 8000 --reload NOTE: Be sure to merge the latest from upstream before making a pull request!","title":"Before Start"},{"location":"example/","text":"Sending email with FastApi \u00b6 List of Useful Examples \u00b6 from fastapi import ( FastAPI , BackgroundTasks , UploadFile , File , Form , Query , Body , Depends ) from starlette.responses import JSONResponse from starlette.requests import Request from fastapi_mail import FastMail , MessageSchema , ConnectionConfig from pydantic import EmailStr , BaseModel from typing import List from fastapi_mail.email_utils import DefaultChecker class EmailSchema ( BaseModel ): email : List [ EmailStr ] conf = ConnectionConfig ( MAIL_USERNAME = \"YourUsername\" , MAIL_PASSWORD = \"strong_password\" , MAIL_FROM = \"your@email.com\" , MAIL_PORT = 587 , MAIL_SERVER = \"your mail server\" , MAIL_FROM_NAME = \"Desired Name\" , MAIL_TLS = True , MAIL_SSL = False , USE_CREDENTIALS = True , VALIDATE_CERTS = True ) app = FastAPI () html = \"\"\" <p>Hi this test mail, thanks for using Fastapi-mail</p> \"\"\" @app . post ( \"/email\" ) async def simple_send ( email : EmailSchema ) -> JSONResponse : message = MessageSchema ( subject = \"Fastapi-Mail module\" , recipients = email . dict () . get ( \"email\" ), # List of recipients, as many as you can pass body = html , subtype = \"html\" ) fm = FastMail ( conf ) await fm . send_message ( message ) return JSONResponse ( status_code = 200 , content = { \"message\" : \"email has been sent\" }) Email as background task \u00b6 @app . post ( \"/emailbackground\" ) async def send_in_background ( background_tasks : BackgroundTasks , email : EmailSchema ) -> JSONResponse : message = MessageSchema ( subject = \"Fastapi mail module\" , recipients = email . dict () . get ( \"email\" ), body = \"Simple background task\" , ) fm = FastMail ( conf ) background_tasks . add_task ( fm . send_message , message ) return JSONResponse ( status_code = 200 , content = { \"message\" : \"email has been sent\" }) Sending files \u00b6 @app . post ( \"/file\" ) async def send_file ( background_tasks : BackgroundTasks , file : UploadFile = File ( ... ), email : EmailStr = Form ( ... ) ) -> JSONResponse : message = MessageSchema ( subject = \"Fastapi mail module\" , recipients = [ email ], body = \"Simple background task \" , attachments = [ file ] ) fm = FastMail ( conf ) background_tasks . add_task ( fm . send_message , message ) return JSONResponse ( status_code = 200 , content = { \"message\" : \"email has been sent\" }) Using Jinja2 HTML Templates \u00b6 You can enable Jinja2 HTML Template emails by setting the TEMPLATE_FOLDER configuration option, and supplying a value (which is just the name of the template file within the TEMPLATE_FOLDER dir) for the template_name parameter in FastMail.send_message() . You then can pass a Dict as the template_body property of your MessageSchema object: class EmailSchema ( BaseModel ): email : List [ EmailStr ] body : Dict [ str , Any ] conf = ConnectionConfig ( MAIL_USERNAME = \"YourUsername\" , MAIL_PASSWORD = \"strong_password\" , MAIL_FROM = \"your@email.com\" , MAIL_PORT = 587 , MAIL_SERVER = \"your mail server\" , MAIL_TLS = True , MAIL_SSL = False , TEMPLATE_FOLDER = Path ( __file__ ) . parent / 'templates' , ) @app . post ( \"/email\" ) async def send_with_template ( email : EmailSchema ) -> JSONResponse : message = MessageSchema ( subject = \"Fastapi-Mail module\" , recipients = email . dict () . get ( \"email\" ), # List of recipients, as many as you can pass template_body = email . dict () . get ( \"body\" ), ) fm = FastMail ( conf ) await fm . send_message ( message , template_name = \"email_template.html\" ) return JSONResponse ( status_code = 200 , content = { \"message\" : \"email has been sent\" }) For example, assume we pass a template_body of: { \"first_name\" : \"Fred\" , \"last_name\" : \"Fredsson\" } We can reference the variables in our Jinja templates as per normal: ... <span>Hello, {{ first_name }}!</span> ... Legacy Behaviour (<= 0.4.0) \u00b6 The original behaviour in <= 0.4.0 was to wrap the Dict you provide in a variable named body when it was provided to Jinja behind the scenes. In these versions, you can then access your dict in your template like so: ... <span>Hello, body.first_name !</span> ... As you can see our keys in our dict are no longer the top level, they are part of the body variable. Nesting works as per normal below this level also. Guide for email utils \u00b6 The utility allows you to check temporary email addresses, you can block any email or domain. You can connect Redis to save and check email addresses. If you do not provide a Redis configuration, then the utility will save it in the list or set by default. Check dispasoble email address \u00b6 async def default_checker (): checker = DefaultChecker () # you can pass source argument for your own email domains await checker . fetch_temp_email_domains () # require to fetch temporary email domains return checker @app . get ( '/email/dispasoble' ) async def simple_send ( domain : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : if await checker . is_dispasoble ( domain ): return JSONResponse ( status_code = 400 , content = { 'message' : 'this is dispasoble domain' }) return JSONResponse ( status_code = 200 , content = { 'message' : 'email has been sent' }) Add dispasoble email address \u00b6 @app . post ( '/email/dispasoble' ) async def add_disp_domain ( domains : list = Body ( ... , embed = True ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : res = await checker . add_temp_domain ( domains ) return JSONResponse ( status_code = 200 , content = { 'result' : res }) Add domain to blocked list \u00b6 @app . post ( '/email/blocked/domains' ) async def block_domain ( domain : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : await checker . blacklist_add_domain ( domain ) return JSONResponse ( status_code = 200 , content = { 'message' : f ' { domain } added to blacklist' }) Check domain blocked or not \u00b6 @app . get ( '/email/blocked/domains' ) async def get_blocked_domain ( domain : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : res = await checker . is_blocked_domain ( domain ) return JSONResponse ( status_code = 200 , content = { \"result\" : res }) Add email address to blocked list \u00b6 @app . post ( '/email/blocked/address' ) async def block_address ( email : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : await checker . blacklist_add_email ( email ) return JSONResponse ( status_code = 200 , content = { \"result\" : True }) Check email blocked or not \u00b6 @app . get ( '/email/blocked/address' ) async def get_block_address ( email : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker )) -> JSONResponse : res = await checker . is_blocked_address ( email ) return JSONResponse ( status_code = 200 , content = { \"result\" : res }) Check MX record \u00b6 @app . get ( '/email/mx' ) async def test_mx ( email : EmailStr = Query ( ... ), full_result : bool = Query ( False ) , checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : domain = email . split ( \"@\" )[ - 1 ] res = await checker . check_mx_record ( domain , full_result ) return JSONResponse ( status_code = 200 , content = res ) Remove email address from blocked list \u00b6 @app . delete ( '/email/blocked/address' ) async def del_blocked_address ( email : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : res = await checker . blacklist_rm_email ( email ) return JSONResponse ( status_code = 200 , content = { \"result\" : res }) Remove domain from blocked list \u00b6 @app . delete ( '/email/blocked/domains' ) async def del_blocked_domain ( domain : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : res = await checker . blacklist_rm_domain ( domain ) return JSONResponse ( status_code = 200 , content = { \"result\" : res }) Remove domain from temporary list \u00b6 @app . delete ( '/email/dispasoble' ) async def del_disp_domain ( domains : list = Body ( ... , embed = True ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : res = await checker . blacklist_rm_temp ( domains ) return JSONResponse ( status_code = 200 , content = { 'result' : res }) Use email utils with Redis \u00b6 async def default_checker (): checker = DefaultChecker ( db_provider = \"redis\" ) await checker . init_redis () return checker WhoIsXmlApi \u00b6 from email_utils import WhoIsXmlApi who_is = WhoIsXmlApi ( token = \"Your access token\" , email = \"your@mailaddress.com\" ) print ( who_is . smtp_check_ ()) #check smtp server print ( who_is . is_dispasoble ()) # check email is disposable or not print ( who_is . check_mx_record ()) # check domain mx records print ( who_is . free_check ) # check email domain is free or not Unittests using FastapiMail \u00b6 Fastapi mails allows you to write unittest for your application without sending emails to non existent email address by mocking the email to be sent. To mock sending out mails, set the suppress configuraton to true. Suppress send defaults to False to prevent mocking within applications. application.py conf = ConnectionConfig ( MAIL_USERNAME = \"YourUsername\" , MAIL_PASSWORD = \"strong_password\" , MAIL_FROM = \"your@email.com\" , MAIL_PORT = 587 , MAIL_SERVER = \"your mail server\" , MAIL_TLS = True , MAIL_SSL = False , TEMPLATE_FOLDER = Path ( __file__ ) . parent / 'templates' , # if no indicated SUPPRESS_SEND defaults to 0 (false) as below # SUPPRESS_SEND=1 ) fm = FastMail ( conf ) @app . post ( \"/email\" ) async def simple_send ( email : EmailSchema ) -> JSONResponse : message = MessageSchema ( subject = \"Testing\" , recipients = email . dict () . get ( \"email\" ), # List of recipients, as many as you can pass body = html , subtype = \"html\" ) await fm . send_message ( message ) return JSONResponse ( status_code = 200 , content = { \"message\" : \"email has been sent\" }) test.py from starlette.testclient import TestClient from .application import app , fm client = TestClient ( app ) def test_send_msg (): fm . config . SUPPRESS_SEND = 1 with fm . record_messages () as outbox : payload = { \"email\" : [ \"user@example.com\" ]} response = client . post ( \"/email\" , json = payload ) assert response . status_code == 200 assert len ( outbox ) == 1 assert outbox [ 0 ][ 'from' ] == \"your@email.com\" assert outbox [ 0 ][ 'To' ] == \"user@example.com\"","title":"Example"},{"location":"example/#sending-email-with-fastapi","text":"","title":"Sending email with FastApi"},{"location":"example/#list-of-useful-examples","text":"from fastapi import ( FastAPI , BackgroundTasks , UploadFile , File , Form , Query , Body , Depends ) from starlette.responses import JSONResponse from starlette.requests import Request from fastapi_mail import FastMail , MessageSchema , ConnectionConfig from pydantic import EmailStr , BaseModel from typing import List from fastapi_mail.email_utils import DefaultChecker class EmailSchema ( BaseModel ): email : List [ EmailStr ] conf = ConnectionConfig ( MAIL_USERNAME = \"YourUsername\" , MAIL_PASSWORD = \"strong_password\" , MAIL_FROM = \"your@email.com\" , MAIL_PORT = 587 , MAIL_SERVER = \"your mail server\" , MAIL_FROM_NAME = \"Desired Name\" , MAIL_TLS = True , MAIL_SSL = False , USE_CREDENTIALS = True , VALIDATE_CERTS = True ) app = FastAPI () html = \"\"\" <p>Hi this test mail, thanks for using Fastapi-mail</p> \"\"\" @app . post ( \"/email\" ) async def simple_send ( email : EmailSchema ) -> JSONResponse : message = MessageSchema ( subject = \"Fastapi-Mail module\" , recipients = email . dict () . get ( \"email\" ), # List of recipients, as many as you can pass body = html , subtype = \"html\" ) fm = FastMail ( conf ) await fm . send_message ( message ) return JSONResponse ( status_code = 200 , content = { \"message\" : \"email has been sent\" })","title":"List of Useful Examples"},{"location":"example/#email-as-background-task","text":"@app . post ( \"/emailbackground\" ) async def send_in_background ( background_tasks : BackgroundTasks , email : EmailSchema ) -> JSONResponse : message = MessageSchema ( subject = \"Fastapi mail module\" , recipients = email . dict () . get ( \"email\" ), body = \"Simple background task\" , ) fm = FastMail ( conf ) background_tasks . add_task ( fm . send_message , message ) return JSONResponse ( status_code = 200 , content = { \"message\" : \"email has been sent\" })","title":"Email as background task"},{"location":"example/#sending-files","text":"@app . post ( \"/file\" ) async def send_file ( background_tasks : BackgroundTasks , file : UploadFile = File ( ... ), email : EmailStr = Form ( ... ) ) -> JSONResponse : message = MessageSchema ( subject = \"Fastapi mail module\" , recipients = [ email ], body = \"Simple background task \" , attachments = [ file ] ) fm = FastMail ( conf ) background_tasks . add_task ( fm . send_message , message ) return JSONResponse ( status_code = 200 , content = { \"message\" : \"email has been sent\" })","title":"Sending files"},{"location":"example/#using-jinja2-html-templates","text":"You can enable Jinja2 HTML Template emails by setting the TEMPLATE_FOLDER configuration option, and supplying a value (which is just the name of the template file within the TEMPLATE_FOLDER dir) for the template_name parameter in FastMail.send_message() . You then can pass a Dict as the template_body property of your MessageSchema object: class EmailSchema ( BaseModel ): email : List [ EmailStr ] body : Dict [ str , Any ] conf = ConnectionConfig ( MAIL_USERNAME = \"YourUsername\" , MAIL_PASSWORD = \"strong_password\" , MAIL_FROM = \"your@email.com\" , MAIL_PORT = 587 , MAIL_SERVER = \"your mail server\" , MAIL_TLS = True , MAIL_SSL = False , TEMPLATE_FOLDER = Path ( __file__ ) . parent / 'templates' , ) @app . post ( \"/email\" ) async def send_with_template ( email : EmailSchema ) -> JSONResponse : message = MessageSchema ( subject = \"Fastapi-Mail module\" , recipients = email . dict () . get ( \"email\" ), # List of recipients, as many as you can pass template_body = email . dict () . get ( \"body\" ), ) fm = FastMail ( conf ) await fm . send_message ( message , template_name = \"email_template.html\" ) return JSONResponse ( status_code = 200 , content = { \"message\" : \"email has been sent\" }) For example, assume we pass a template_body of: { \"first_name\" : \"Fred\" , \"last_name\" : \"Fredsson\" } We can reference the variables in our Jinja templates as per normal: ... <span>Hello, {{ first_name }}!</span> ...","title":"Using Jinja2 HTML Templates"},{"location":"example/#legacy-behaviour-040","text":"The original behaviour in <= 0.4.0 was to wrap the Dict you provide in a variable named body when it was provided to Jinja behind the scenes. In these versions, you can then access your dict in your template like so: ... <span>Hello, body.first_name !</span> ... As you can see our keys in our dict are no longer the top level, they are part of the body variable. Nesting works as per normal below this level also.","title":"Legacy Behaviour (&lt;= 0.4.0)"},{"location":"example/#guide-for-email-utils","text":"The utility allows you to check temporary email addresses, you can block any email or domain. You can connect Redis to save and check email addresses. If you do not provide a Redis configuration, then the utility will save it in the list or set by default.","title":"Guide for email utils"},{"location":"example/#check-dispasoble-email-address","text":"async def default_checker (): checker = DefaultChecker () # you can pass source argument for your own email domains await checker . fetch_temp_email_domains () # require to fetch temporary email domains return checker @app . get ( '/email/dispasoble' ) async def simple_send ( domain : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : if await checker . is_dispasoble ( domain ): return JSONResponse ( status_code = 400 , content = { 'message' : 'this is dispasoble domain' }) return JSONResponse ( status_code = 200 , content = { 'message' : 'email has been sent' })","title":"Check dispasoble email address"},{"location":"example/#add-dispasoble-email-address","text":"@app . post ( '/email/dispasoble' ) async def add_disp_domain ( domains : list = Body ( ... , embed = True ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : res = await checker . add_temp_domain ( domains ) return JSONResponse ( status_code = 200 , content = { 'result' : res })","title":"Add dispasoble email address"},{"location":"example/#add-domain-to-blocked-list","text":"@app . post ( '/email/blocked/domains' ) async def block_domain ( domain : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : await checker . blacklist_add_domain ( domain ) return JSONResponse ( status_code = 200 , content = { 'message' : f ' { domain } added to blacklist' })","title":"Add domain to blocked list"},{"location":"example/#check-domain-blocked-or-not","text":"@app . get ( '/email/blocked/domains' ) async def get_blocked_domain ( domain : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : res = await checker . is_blocked_domain ( domain ) return JSONResponse ( status_code = 200 , content = { \"result\" : res })","title":"Check domain blocked or not"},{"location":"example/#add-email-address-to-blocked-list","text":"@app . post ( '/email/blocked/address' ) async def block_address ( email : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : await checker . blacklist_add_email ( email ) return JSONResponse ( status_code = 200 , content = { \"result\" : True })","title":"Add email address to blocked list"},{"location":"example/#check-email-blocked-or-not","text":"@app . get ( '/email/blocked/address' ) async def get_block_address ( email : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker )) -> JSONResponse : res = await checker . is_blocked_address ( email ) return JSONResponse ( status_code = 200 , content = { \"result\" : res })","title":"Check email blocked or not"},{"location":"example/#check-mx-record","text":"@app . get ( '/email/mx' ) async def test_mx ( email : EmailStr = Query ( ... ), full_result : bool = Query ( False ) , checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : domain = email . split ( \"@\" )[ - 1 ] res = await checker . check_mx_record ( domain , full_result ) return JSONResponse ( status_code = 200 , content = res )","title":"Check MX record"},{"location":"example/#remove-email-address-from-blocked-list","text":"@app . delete ( '/email/blocked/address' ) async def del_blocked_address ( email : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : res = await checker . blacklist_rm_email ( email ) return JSONResponse ( status_code = 200 , content = { \"result\" : res })","title":"Remove email address from blocked list"},{"location":"example/#remove-domain-from-blocked-list","text":"@app . delete ( '/email/blocked/domains' ) async def del_blocked_domain ( domain : str = Query ( ... ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : res = await checker . blacklist_rm_domain ( domain ) return JSONResponse ( status_code = 200 , content = { \"result\" : res })","title":"Remove domain from blocked list"},{"location":"example/#remove-domain-from-temporary-list","text":"@app . delete ( '/email/dispasoble' ) async def del_disp_domain ( domains : list = Body ( ... , embed = True ), checker : DefaultChecker = Depends ( default_checker ) ) -> JSONResponse : res = await checker . blacklist_rm_temp ( domains ) return JSONResponse ( status_code = 200 , content = { 'result' : res })","title":"Remove domain from temporary list"},{"location":"example/#use-email-utils-with-redis","text":"async def default_checker (): checker = DefaultChecker ( db_provider = \"redis\" ) await checker . init_redis () return checker","title":"Use email utils with Redis"},{"location":"example/#whoisxmlapi","text":"from email_utils import WhoIsXmlApi who_is = WhoIsXmlApi ( token = \"Your access token\" , email = \"your@mailaddress.com\" ) print ( who_is . smtp_check_ ()) #check smtp server print ( who_is . is_dispasoble ()) # check email is disposable or not print ( who_is . check_mx_record ()) # check domain mx records print ( who_is . free_check ) # check email domain is free or not","title":"WhoIsXmlApi"},{"location":"example/#unittests-using-fastapimail","text":"Fastapi mails allows you to write unittest for your application without sending emails to non existent email address by mocking the email to be sent. To mock sending out mails, set the suppress configuraton to true. Suppress send defaults to False to prevent mocking within applications. application.py conf = ConnectionConfig ( MAIL_USERNAME = \"YourUsername\" , MAIL_PASSWORD = \"strong_password\" , MAIL_FROM = \"your@email.com\" , MAIL_PORT = 587 , MAIL_SERVER = \"your mail server\" , MAIL_TLS = True , MAIL_SSL = False , TEMPLATE_FOLDER = Path ( __file__ ) . parent / 'templates' , # if no indicated SUPPRESS_SEND defaults to 0 (false) as below # SUPPRESS_SEND=1 ) fm = FastMail ( conf ) @app . post ( \"/email\" ) async def simple_send ( email : EmailSchema ) -> JSONResponse : message = MessageSchema ( subject = \"Testing\" , recipients = email . dict () . get ( \"email\" ), # List of recipients, as many as you can pass body = html , subtype = \"html\" ) await fm . send_message ( message ) return JSONResponse ( status_code = 200 , content = { \"message\" : \"email has been sent\" }) test.py from starlette.testclient import TestClient from .application import app , fm client = TestClient ( app ) def test_send_msg (): fm . config . SUPPRESS_SEND = 1 with fm . record_messages () as outbox : payload = { \"email\" : [ \"user@example.com\" ]} response = client . post ( \"/email\" , json = payload ) assert response . status_code == 200 assert len ( outbox ) == 1 assert outbox [ 0 ][ 'from' ] == \"your@email.com\" assert outbox [ 0 ][ 'To' ] == \"user@example.com\"","title":"Unittests using FastapiMail"},{"location":"getting-started/","text":"\ud83d\udd79 Guide \u00b6 After installing the module and setting up your FastApi app: Main classes and packages are FastMail ConnectionConfig MessageSchema email_utils.DefaultChecker email_utils.WhoIsXmlApi FastMail class \u00b6 class has following attributes and methods config : ConnectionConfig class should be passed in order to establish connection send_message : The methods has two atributes, message: MessageSchema, template_name=None message : where you define message sturcture for email template_name : if you are using jinja2 consider template_name as well for passing HTML. ConnectionConfig class \u00b6 class has following attributes MAIL_USERNAME : Username for email, some email hosts separates username from the default sender(AWS). If you service does not provide username use sender address for connection. MAIL_PASSWORD : Password for authentication MAIL_SERVER : SMTP Mail server. MAIL_TLS : For TLS connection MAIL_SSL : For TLS connection MAIL_DEBUG : Debug mode for while sending mails, defaults 0. MAIL_FROM : Sender address MAIL_FROM_NAME : Title for Mail TEMPLATE_FOLDER: If you are using jinja2, specify template folder name SUPPRESS_SEND: To mock sending out mail, defaults 0. USE_CREDENTIALS: Defaults to True . However it enables users to choose whether or not to login to their SMTP server. VALIDATE_CERTS: Defaults to True . It enables to choose whether to verify the mail server's certificate MessageSchema class \u00b6 class has following attributes recipients : List of recipients. attachments : attachments within mail subject : subject content of the mail body : body of the message cc : cc recipients of the mail bcc : bcc recipients of the mail reply_to : Reply-To recipients in the mail charset : charset defaults to utf-8 subtype : subtype of the mail defaults to plain email_utils.DefaultChecker class \u00b6 Default class for checking email from collected public resource. The class makes it possible to use redis to save data. source : optional source for collected email data. db_provider : switch to redis email_utils.WhoIsXmlApi class \u00b6 WhoIsXmlApi class provide working with api WhoIsXmlApi This service gives free 1000 request to checking email address per month. token : token you can get from this WhoIsXmlApi link email : email for checking","title":"\ud83d\udd79 Getting Started"},{"location":"getting-started/#guide","text":"After installing the module and setting up your FastApi app: Main classes and packages are FastMail ConnectionConfig MessageSchema email_utils.DefaultChecker email_utils.WhoIsXmlApi","title":"\ud83d\udd79 Guide"},{"location":"getting-started/#fastmail-class","text":"class has following attributes and methods config : ConnectionConfig class should be passed in order to establish connection send_message : The methods has two atributes, message: MessageSchema, template_name=None message : where you define message sturcture for email template_name : if you are using jinja2 consider template_name as well for passing HTML.","title":"FastMail class"},{"location":"getting-started/#connectionconfig-class","text":"class has following attributes MAIL_USERNAME : Username for email, some email hosts separates username from the default sender(AWS). If you service does not provide username use sender address for connection. MAIL_PASSWORD : Password for authentication MAIL_SERVER : SMTP Mail server. MAIL_TLS : For TLS connection MAIL_SSL : For TLS connection MAIL_DEBUG : Debug mode for while sending mails, defaults 0. MAIL_FROM : Sender address MAIL_FROM_NAME : Title for Mail TEMPLATE_FOLDER: If you are using jinja2, specify template folder name SUPPRESS_SEND: To mock sending out mail, defaults 0. USE_CREDENTIALS: Defaults to True . However it enables users to choose whether or not to login to their SMTP server. VALIDATE_CERTS: Defaults to True . It enables to choose whether to verify the mail server's certificate","title":"ConnectionConfig class"},{"location":"getting-started/#messageschema-class","text":"class has following attributes recipients : List of recipients. attachments : attachments within mail subject : subject content of the mail body : body of the message cc : cc recipients of the mail bcc : bcc recipients of the mail reply_to : Reply-To recipients in the mail charset : charset defaults to utf-8 subtype : subtype of the mail defaults to plain","title":"MessageSchema class"},{"location":"getting-started/#email_utilsdefaultchecker-class","text":"Default class for checking email from collected public resource. The class makes it possible to use redis to save data. source : optional source for collected email data. db_provider : switch to redis","title":"email_utils.DefaultChecker class"},{"location":"getting-started/#email_utilswhoisxmlapi-class","text":"WhoIsXmlApi class provide working with api WhoIsXmlApi This service gives free 1000 request to checking email address per month. token : token you can get from this WhoIsXmlApi link email : email for checking","title":"email_utils.WhoIsXmlApi class"},{"location":"install/","text":"Using pip \u00b6 python3 -m venv .venv source .venv/bin/activate pip install fastapi-mail","title":"\ud83d\udd28 Installation"},{"location":"install/#using-pip","text":"python3 -m venv .venv source .venv/bin/activate pip install fastapi-mail","title":"Using pip"}]}